/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. typescript.jj */
/*@egen*/options{
    IGNORE_CASE=true;
                                           
                                                            
               
                 
   DEBUG_PARSER=false;
   DEBUG_TOKEN_MANAGER=false;
}

PARSER_BEGIN(TypeScriptParser)
package wci.frontend;
import java.util.*;
import java.util.ArrayList;
import java.io.*;

import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.backend.*;
import wci.util.*;

import wci.intermediate.icodeimpl.ICodeNodeImpl;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class TypeScriptParser/*@bgen(jjtree)*/implements TypeScriptParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTTypeScriptParserState jjtree = new JJTTypeScriptParserState();

/*@egen*/
    private static SymTabStack symTabStack;
    private static SymTabEntry programId;
	public static boolean generate_code_flag = true;
    public static void main(String[] args)
        throws Exception
    {
    	// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);
        
        String sourceFilePath = args[0];
        
        // Parse a Typescript program.
        Reader    reader = new FileReader(sourceFilePath);
        TypeScriptParser parser = new TypeScriptParser(reader);
        SimpleNode rootNode = parser.program();
		rootNode.dump(">");
        // Print the cross-reference table.
		CrossReferencer crossReferencer = new CrossReferencer();
		crossReferencer.print(symTabStack);

        // Visit the parse tree nodes to decorate them with type information.
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);
        
        // Print the parse tree.
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);
		if(generate_code_flag)
		{
	        Backend backend = BackendFactory.createBackend("compile");
	        backend.process(iCode, symTabStack, objectFileName(sourceFilePath));
		}
		else
		{			System.out.println("COULD NOT GENERATE CODE DUE TO SYNTAX ERRORS");
		}
    }

    private static String fileNameWithoutExtension(String fileName) {
        int dotIndex = fileName.lastIndexOf('.');
        return fileName.substring(0, dotIndex);
    }

    private static String objectFileName(String fileName) {
        return fileNameWithoutExtension(fileName) + ".j";
    }
}
PARSER_END(TypeScriptParser)

SKIP: {
  " " | "\r" | "\t" | "\n"
  | <"//" (~["\n"])* ("\n"|"\r")?>
}

TOKEN : { //useful regex
	<#DIGIT  : ["0"-"9"]>
    |<#ONE_TO_NINE: ["1"-"9"] >
	//A-Z only if ignore case option is false
	| <#LETTER : ["a"-"z","A"-"Z"]>
	| <#SPACE: [" "] >
}

TOKEN : {//Reserved words
	<VAR : "var">
	| <IF : "if">
	| <ELSE_IF :"else if">
 	| <ELSE : "else">
 	| <FUNCTION : "function">
 	| <BOOLEAN : "boolean">
 	| <NUMBER : "number">
 	| <STRING : "char"> // made string parse as char so we can use pascal string
 	| <ENUM : "enum">
 	| <INTERFACE : "interface">
 	| <RETURN : "return">
 	| <VOID : "void">
 	| <WHILE : "while">
 	// Println is considered a reserved word for now. Might just want to make it part of the runtime library later.
 	| <PRINTLN : "println">
 	| <TRUE: "true" >
 	| <FALSE: "false" >
}

TOKEN : {//Symbols
	<NOT : "!"> 
	| <AMPRSAND : "&">
	| <MUL : "*">
	| <MINUS : "-">
	| <PLUS : "+">
	| <EQ : "=">
	| <BAR : "|">
	| <DIV : "/">
	| <COLON : ":">
	| <SEMICOLON : ";">
	| <QM : "?">
	| <COMMA : ",">
	| <DOT : ".">
	| <SINGLE_QUOTE : "'">
	| <QUOTE : "\"">
	| <LEFT_PARAN : "(">
	| <RIGHT_PARAN : ")">
	| <LEFT_BRAKET : "[">
	| <RIGHT_BRAKET : "]">
	| <LEFT_BRACE : "{"> 
	| <RIGHT_BRACE : "}">
	| <UNDER_SCORE : "_">
	| <LT : "<">
	| <GT : ">">
	| <LE : "<=">
	| <GE : ">=">
	| <DOUBLE_EQ : "==">
	| <OR : "||">
	| <AND : "&&">
	| <NOT_EQ : "!=">
}

TOKEN :
{
  <MATH_OP : <PLUS> | <MINUS> | <MUL> | <DIV> > 
}

TOKEN : {//Character String and Strings
	<STRING_LITERAL : <QUOTE> (~["\""])* <QUOTE> | <SINGLE_QUOTE> (~[]){1} <SINGLE_QUOTE> >
}

TOKEN : {//Identifier
	<IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | "_")*>
}

/* TypeScript treats real and integers as Numbers*/
TOKEN : {//Numbers
	<NUM: <INTEGER> | <REAL>> 
	| <INTEGER: (<SIGN>)? (<DIGIT>)+ | (<ONE_TO_NINE> (<DIGIT>)+) >
	| <REAL: (<SIGN>)? (<DIGIT>)+ "." | (<SIGN>)? "." (<DIGIT>)+ | (<SIGN>)? (<DIGIT>)+ "." (<DIGIT>)+ >

	//for simple version you cant have -5 parse as number 
 	| <#SIGN: "" >
}

TOKEN: { /*	Error token */
    <ERROR : ~["\r", "\n"]>
}

SimpleNode program() : {/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) program */
        try {
/*@egen*/
	// Cross listing requires a program ID don't wana take it out
	{	  
	programId = symTabStack.enterLocal("TypeScript");
	programId.setTypeSpec(Predefined.charType);
	programId.setDefinition(DefinitionImpl.PROGRAM);
	programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
	programId.setAttribute(FUNCTIONS_CODE, new ArrayList<SimpleNode>());
  	jjtn000.setTypeSpec(Predefined.charType);
	
	symTabStack.setProgramId(programId);
	}
        Statement_list()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        {
            return jjtn000;
        }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/*if statements*/
void boolean_op() : {/*@bgen(jjtree) boolean_op */
                     ASTboolean_op jjtn000 = new ASTboolean_op(JJTBOOLEAN_OP);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/jjtn000.setAttribute(IS_WHILE, false);}
{/*@bgen(jjtree) boolean_op */
        try {
/*@egen*//*@bgen(jjtree) LESS_THAN */
        {
          ASTLESS_THAN jjtn001 = new ASTLESS_THAN(JJTLESS_THAN);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	<LT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/            |/*@bgen(jjtree) GREATER_THAN */
         {
           ASTGREATER_THAN jjtn002 = new ASTGREATER_THAN(JJTGREATER_THAN);
           boolean jjtc002 = true;
           jjtree.openNodeScope(jjtn002);
         }
         try {
/*@egen*/
	 <GT>/*@bgen(jjtree)*/
         } finally {
           if (jjtc002) {
             jjtree.closeNodeScope(jjtn002, true);
           }
         }
/*@egen*/               |/*@bgen(jjtree) LESS_THAN_OR_EQUALS */
          {
            ASTLESS_THAN_OR_EQUALS jjtn003 = new ASTLESS_THAN_OR_EQUALS(JJTLESS_THAN_OR_EQUALS);
            boolean jjtc003 = true;
            jjtree.openNodeScope(jjtn003);
          }
          try {
/*@egen*/
	  <LE>/*@bgen(jjtree)*/
          } finally {
            if (jjtc003) {
              jjtree.closeNodeScope(jjtn003, true);
            }
          }
/*@egen*/                      |/*@bgen(jjtree) GREATER_THAN_OR_EQUALS */
           {
             ASTGREATER_THAN_OR_EQUALS jjtn004 = new ASTGREATER_THAN_OR_EQUALS(JJTGREATER_THAN_OR_EQUALS);
             boolean jjtc004 = true;
             jjtree.openNodeScope(jjtn004);
           }
           try {
/*@egen*/
	   <GE>/*@bgen(jjtree)*/
           } finally {
             if (jjtc004) {
               jjtree.closeNodeScope(jjtn004, true);
             }
           }
/*@egen*/                         |/*@bgen(jjtree) EQUALITY */
            {
              ASTEQUALITY jjtn005 = new ASTEQUALITY(JJTEQUALITY);
              boolean jjtc005 = true;
              jjtree.openNodeScope(jjtn005);
            }
            try {
/*@egen*/
	    <DOUBLE_EQ>/*@bgen(jjtree)*/
            } finally {
              if (jjtc005) {
                jjtree.closeNodeScope(jjtn005, true);
              }
            }
/*@egen*/           |/*@bgen(jjtree) NOT_EQUALS */
             {
               ASTNOT_EQUALS jjtn006 = new ASTNOT_EQUALS(JJTNOT_EQUALS);
               boolean jjtc006 = true;
               jjtree.openNodeScope(jjtn006);
             }
             try {
/*@egen*/
	     <NOT_EQ>/*@bgen(jjtree)*/
             } finally {
               if (jjtc006) {
                 jjtree.closeNodeScope(jjtn006, true);
               }
             }
/*@egen*/             |/*@bgen(jjtree) OR */
             {
               ASTOR jjtn007 = new ASTOR(JJTOR);
               boolean jjtc007 = true;
               jjtree.openNodeScope(jjtn007);
             }
             try {
/*@egen*/ 
	     <OR>/*@bgen(jjtree)*/
             } finally {
               if (jjtc007) {
                 jjtree.closeNodeScope(jjtn007, true);
               }
             }
/*@egen*/     |/*@bgen(jjtree) AND */
              {
                ASTAND jjtn008 = new ASTAND(JJTAND);
                boolean jjtc008 = true;
                jjtree.openNodeScope(jjtn008);
              }
              try {
/*@egen*/
	      <AND>/*@bgen(jjtree)*/
              } finally {
                if (jjtc008) {
                  jjtree.closeNodeScope(jjtn008, true);
                }
              }
/*@egen*/     /*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void condition() : {/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) condition */
        try {
/*@egen*/
	<LEFT_PARAN>
	(Expression() (boolean_op() Expression())? )
	<RIGHT_PARAN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


//if statement grammar 
void if_body(): {/*@bgen(jjtree) if_body */
  ASTif_body jjtn000 = new ASTif_body(JJTIF_BODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) if_body */
        try {
/*@egen*/
	Compound_stmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void if_stmt() :{/*@bgen(jjtree) if_stmt */
  ASTif_stmt jjtn000 = new ASTif_stmt(JJTIF_STMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) if_stmt */
        try {
/*@egen*/
	if_part() (else_part())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void if_part(): {/*@bgen(jjtree) if_part */
  ASTif_part jjtn000 = new ASTif_part(JJTIF_PART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) if_part */
        try {
/*@egen*/
	<IF> condition() if_body()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void else_part(): {/*@bgen(jjtree) else_part */
  ASTelse_part jjtn000 = new ASTelse_part(JJTELSE_PART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) else_part */
        try {
/*@egen*/
	<ELSE> if_body()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void while_node() : {/*@bgen(jjtree) while_node */
  ASTwhile_node jjtn000 = new ASTwhile_node(JJTWHILE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) while_node */
        try {
/*@egen*/
	<WHILE> condition() Compound_stmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void Statement()       : {}
{
   	try
	{
	  LOOKAHEAD(3)
     Assignment() | if_stmt() | while_node() | println() | FunctionDeclaration()
   		| Function_invocation()
    } catch(ParseException ex)
   {
		HashSet syncSet = new HashSet();
        syncSet.add(SEMICOLON);
        syncSet.add(LEFT_BRACE);
        syncSet.add(RIGHT_BRACE);
        syncSet.add(EOF);
        handleError(ex, syncSet, true);
   }
}

void Compound_stmt() : {/*@bgen(jjtree) Compound_stmt */
  ASTCompound_stmt jjtn000 = new ASTCompound_stmt(JJTCOMPOUND_STMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Compound_stmt */
        try {
/*@egen*/
  	<LEFT_BRACE> Statement_list() <RIGHT_BRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statement_list()      : {}
{
  		(
  	  		Statement()
  	  	)+
}

void println() : {/*@bgen(jjtree) println */
  ASTprintln jjtn000 = new ASTprintln(JJTPRINTLN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) println */
    try {
/*@egen*/
    <PRINTLN> <LEFT_PARAN> Expression() <RIGHT_PARAN> <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

//------- Function rules begin -------

void PureFunction() : {/*@bgen(jjtree) PureFunction */
  ASTPureFunction jjtn000 = new ASTPureFunction(JJTPUREFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PureFunction */
    try {
/*@egen*/
    <LEFT_BRACE> Statement_list() (<RETURN> (Expression())? <SEMICOLON>)? <RIGHT_BRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FunctionDeclaration():{/*@bgen(jjtree) FunctionDeclaration */
                            ASTFunctionDeclaration jjtn000 = new ASTFunctionDeclaration(JJTFUNCTIONDECLARATION);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/SymTabEntry funcID; SimpleNode funcNode;}
{/*@bgen(jjtree) FunctionDeclaration */
    try {
/*@egen*/
    <FUNCTION> <IDENTIFIER>
    {
      // enter the function name into a symbol table stack
      funcID = symTabStack.enterLocal(token.image);
      funcID.setDefinition(DefinitionImpl.FUNCTION);
      funcID.appendLineNumber(token.beginLine);
	  jjtn000.setAttribute(ID, funcID);
      jjtn000.setTypeSpec(symTabStack.lookup("void").getTypeSpec());
	  //add all function decl to a list do 
      ArrayList<SimpleNode> funcArr = (ArrayList<SimpleNode>) programId.getAttribute(FUNCTIONS_CODE);
      funcArr.add(jjtn000);
    }
	<LEFT_PARAN>  
  {
  }
   (
	      <IDENTIFIER> {
	          
	      }  
	      <COLON>
	      typeSignature() {
	        	
	      } 
		  (
		      <COMMA>
		      <IDENTIFIER> {
		          
		      }  
		      <COLON>
		      typeSignature() {
		        	
		      }
	     )*
   )?
     {
  	}
    <RIGHT_PARAN>
    <COLON>
   	 typeSignature() {
      // use funcID to set the typespec
     }
     
     PureFunction()/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {
	      // use funcID to set the ROUTINE_CODE
		  // use typespec  or set ROUTINE_RETURN_TYPE to void  or use typspec for both
     }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Function_invocation() :{/*@bgen(jjtree) Function_invocation */
                             ASTFunction_invocation jjtn000 = new ASTFunction_invocation(JJTFUNCTION_INVOCATION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/SymTabEntry funcID; SimpleNode funcNode;}
{/*@bgen(jjtree) Function_invocation */
  try {
/*@egen*/
  <IDENTIFIER>
    {
      funcID = symTabStack.lookup(token.image);
      funcID.setDefinition(DefinitionImpl.FUNCTION);
      funcID.appendLineNumber(token.beginLine);
	  jjtn000.setAttribute(ID, funcID);  
    }
	<LEFT_PARAN>  
   (
     Expression() {
	          
	      }  
		(
		      <COMMA>
		      Expression() {
		          
		      }  
	     )*
   )?
   <RIGHT_PARAN>
   <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
//------- Function rules end -------

void declaration() :{/*@bgen(jjtree) declaration */
  ASTdeclaration jjtn000 = new ASTdeclaration(JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) declaration */
  try {
/*@egen*/
  VarIdentifierType() (<EQ> Expression())? <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Assignment() :{/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
  try {
/*@egen*/
  VarIdentifierType() (<EQ> Expression())? <SEMICOLON>|
		<IDENTIFIER>/*@bgen(jjtree) identifier */
                {
                  ASTidentifier jjtn001 = new ASTidentifier(JJTIDENTIFIER);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001, true);
                  jjtc001 = false;
                }
/*@egen*/ 
		{
		  SymTabEntry typeId = symTabStack.lookup(token.image);
          typeId.appendLineNumber(token.beginLine);
          SymTabEntry variableId = symTabStack.lookup(token.image);
		  jjtn001.setAttribute(ID, variableId);
		  jjtn001.setTypeSpec(typeId.getTypeSpec());
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                  }
                }
/*@egen*/              <EQ> Expression() <SEMICOLON>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void VarIdentifierType()       : {}
{
    <VAR> IdentifierType()
}

void IdentifierType()       :{SymTabEntry someID; ICodeNodeImpl old; SimpleNode id;}
{
    <IDENTIFIER>/*@bgen(jjtree) identifier */
    {
      ASTidentifier jjtn001 = new ASTidentifier(JJTIDENTIFIER);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*//*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn001, true);
      jjtc001 = false;
    }
/*@egen*/ 
    {
      someID = symTabStack.enterLocal(token.image);
      processVariableDecl(token, someID);
	  jjtn001.setAttribute(ID, someID);
	  id = jjtn001;
      
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/             <COLON>
    typeSignature()
    {
      SymTabEntry typeId = symTabStack.lookup(token.image);
      typeId.appendLineNumber(token.beginLine);
      TypeSpec type = typeId.getTypeSpec();
      someID.setTypeSpec(type);
      id.setTypeSpec(type);
    }
}

void typeSignature()       :{}
{
	   <NUMBER>
	  |<BOOLEAN>
	  |<STRING>
	  |<VOID>
}

void Expression()       : {}
{
    term() (
        "+" term()/*@bgen(jjtree) #add( 2) */
        {
          ASTadd jjtn001 = new ASTadd(JJTADD);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtc001 = false;
        }
/*@egen*/
        {
           jjtn001.setTypeSpec(Predefined.numberType);
          
        }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/        
      | "-" term()/*@bgen(jjtree) #subtract( 2) */
      {
        ASTsubtract jjtn002 = new ASTsubtract(JJTSUBTRACT);
        boolean jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
      }
      try {
/*@egen*//*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
           jjtn002.setTypeSpec(Predefined.numberType);
        
      }/*@bgen(jjtree)*/
      } finally {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  2);
        }
      }
/*@egen*/             
    )*
}

void simple_expression()       :{}
{
	factor() (("+"|"-"|"/"|"*") simple_expression())?
}

void term()       : {}
{
    factor() (
        "*" factor()/*@bgen(jjtree) #multiply( 2) */
        {
          ASTmultiply jjtn001 = new ASTmultiply(JJTMULTIPLY);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  2);
          jjtc001 = false;
        }
/*@egen*/
        {
           jjtn001.setTypeSpec(Predefined.numberType);
          
        }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
          }
        }
/*@egen*/             
      | "/" factor()/*@bgen(jjtree) #divide( 2) */
      {
        ASTdivide jjtn002 = new ASTdivide(JJTDIVIDE);
        boolean jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
      }
      try {
/*@egen*//*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn002,  2);
        jjtc002 = false;
      }
/*@egen*/
      {
           jjtn002.setTypeSpec(Predefined.numberType);
        
      }/*@bgen(jjtree)*/
      } finally {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  2);
        }
      }
/*@egen*/           
    )*
}

void factor()       : {}
{
  boolean_node()|
    identifier()
  | number()
  | string()
}

void boolean_node() : {/*@bgen(jjtree) boolean_node */
  ASTboolean_node jjtn000 = new ASTboolean_node(JJTBOOLEAN_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) boolean_node */
  try {
/*@egen*/
  (<TRUE> | <FALSE>)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
	SymTabEntry variableId = symTabStack.lookup(token.image);
	variableId.appendLineNumber(token.beginLine);
	TypeSpec type = variableId.getTypeSpec();
	jjtn000.setTypeSpec(type);
	jjtn000.setAttribute(ID, variableId);	 
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void identifier() : {/*@bgen(jjtree) identifier */
  ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) identifier */
  try {
/*@egen*/
  <IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
	SymTabEntry variableId = symTabStack.lookup(token.image);
	variableId.appendLineNumber(token.beginLine);
	TypeSpec type = variableId.getTypeSpec();
	jjtn000.setTypeSpec(type);
	// ID is not really used but might need it later
	jjtn000.setAttribute(ID, variableId); 
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

// try parse integer if not try float if not error 
void number() : {/*@bgen(jjtree) number */
  ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) number */
  try {
/*@egen*/
  <NUM>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	  jjtn000.setTypeSpec(Predefined.numberType);
      jjtn000.setAttribute(VALUE, Double.parseDouble(token.image));
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void string() : {/*@bgen(jjtree) string */
  ASTstring jjtn000 = new ASTstring(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) string */
  try {
/*@egen*/
  <STRING_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
  	  jjtn000.setTypeSpec(Predefined.charType);
	  jjtn000.setAttribute(VALUE, token.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void error() : {/*@bgen(jjtree) error */
  ASTerror jjtn000 = new ASTerror(JJTERROR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) error */
        try {
/*@egen*/
	<ERROR>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

  
JAVACODE
//return the token name in string format
void processVariableDecl(Token token, SymTabEntry variableId)      
{
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
}

JAVACODE
String handleError(ParseException ex, HashSet syncSet, boolean doPop) 
{/*@bgen(jjtree) handleError */
     ASThandleError jjtn000 = new ASThandleError(JJTHANDLEERROR);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     try {
/*@egen*/
  	generate_code_flag = false;
    Token token = ex.currentToken;
    TypeScriptParseException tse = new TypeScriptParseException(ex);
    System.out.println(tse.getMessage());
    while (!syncSet.contains(token.kind))
    {
        token = getNextToken();
    }
    System.out.println(getToken(1).image);
    while (!syncSet.contains(token.kind))
    {
        token = getNextToken();
    }

    return token.image;/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}