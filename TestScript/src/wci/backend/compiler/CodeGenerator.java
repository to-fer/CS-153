package wci.backend.compiler;

import com.sun.org.apache.xpath.internal.operations.Variable;
import wci.backend.Backend;
import wci.frontend.Node;
import wci.intermediate.*;
import wci.intermediate.symtabimpl.DefinitionImpl;
import wci.intermediate.symtabimpl.Predefined;
import wci.intermediate.symtabimpl.SymTabKeyImpl;

import java.io.PrintWriter;
import java.util.List;

/**
 * <p>The code generator for a compiler back end.</p>
 *
 * <p>Copyright (c) 2008 by Ronald Mak</p>
 * <p>For instructional purposes only.  No warranties.</p>
 */
public class CodeGenerator extends Backend
{
    private static final int STACK_LIMIT = 16;
    private static final String PROGRAM_HEADER_CLASS_NAME = "TypeScriptProgram";

    private static final String INTEGER_TYPECODE = "I";
    // TODO Make sure this is the right type code for doubles.
    private static final String DOUBLE_TYPECODE = "D";

    static ICode iCode;
    static SymTabStack symTabStack;
    static PrintWriter objectFile;

    /**
     * Process the intermediate code and the symbol table generated by the
     * parser to generate machine-language instructions.
     * @param iCode the intermediate code.
     * @param symTabStack the symbol table stack.
     * @param objectFilePath the object file path for the generated code.
     * @throws Exception if an error occurred.
     */
    public void process(ICode iCode, SymTabStack symTabStack,
                        String objectFilePath)
        throws Exception
    {
        this.iCode = iCode;
        this.symTabStack = symTabStack;
        objectFile = new PrintWriter(objectFilePath);

        writeProgramClassInfo();
        writeMainMethod();

        objectFile.flush();
        objectFile.close();
    }

    private void writeProgramClassInfo() {
        writeProgramHeader();
        writeLocalVarFields();
        writeProgramClassConstructor();
    }

    private void writeMainMethod() {
        writeMainMethodHeader();
        writeMainMethodBody();
        // TODO Count the locals.
        //objectFile.println(".limit locals " + localsCount);
        objectFile.println(".limit stack " + STACK_LIMIT);
        objectFile.println(".end method");
    }

    private void writeProgramHeader() {
        objectFile.println(".class public " + PROGRAM_HEADER_CLASS_NAME);
        objectFile.println(".super java/lang/Object");
        objectFile.println();
    }

    private void writeLocalVarFields() {
        SymTab routineSymTab = (SymTab) symTabStack.getProgramId().getAttribute(SymTabKeyImpl.ROUTINE_SYMTAB);
        List<SymTabEntry> locals = routineSymTab.sortedEntries();
        for (SymTabEntry id : locals) {
            Definition definition = id.getDefinition();
            if (definition == DefinitionImpl.VARIABLE) {
                String fieldName = id.getName();
                TypeSpec type = id.getTypeSpec();
                String typeCode;
                if (type == Predefined.booleanType || type == Predefined.charType) {
                    typeCode = INTEGER_TYPECODE;
                }
                else if (type == Predefined.numberType) {
                    typeCode = DOUBLE_TYPECODE;
                }
                else {
                    throw new UnsupportedOperationException("That type is not yet implemented in the code generator!");
                }

                objectFile.println(".field private static " + fieldName + " " + typeCode);
            }
        }
        objectFile.println();
    }

    private void writeProgramClassConstructor() {
        objectFile.println(".method public <init>()V");
        objectFile.println();
        objectFile.println("	aload_0");
        objectFile.println("	invokenonvirtual	java/lang/Object/<init>()V");
        objectFile.println("	return");
        objectFile.println();
        objectFile.println(".limit locals 1");
        objectFile.println(".limit stack 1");
        objectFile.println(".end method");
        objectFile.println();
    }

    private void writeMainMethodHeader() {
        objectFile.println(".method public static main([Ljava/lang/String;)V");
        objectFile.println();
    }

    private void writeMainMethodBody() {
        CodeGeneratorVisitor codeVisitor = new CodeGeneratorVisitor();
        Node rootNode = iCode.getRoot();
        rootNode.jjtAccept(codeVisitor, null);

        objectFile.println();
        objectFile.println("    return");
        objectFile.println();
    }
}
