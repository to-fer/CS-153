options{
    IGNORE_CASE=true;
    JJTREE_OUTPUT_DIRECTORY="wci/frontend";
    NODE_EXTENDS="wci.intermediate.icodeimpl.ICodeNodeImpl";
    MULTI=true;
    VISITOR=true;
   DEBUG_PARSER=true;
   DEBUG_TOKEN_MANAGER=false;
}

PARSER_BEGIN(PclParser)
package wci.frontend;
import java.util.*;
import java.util.ArrayList;
import java.io.*;

import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.backend.*;
import wci.util.*;

import wci.intermediate.icodeimpl.ICodeNodeImpl;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class PclParser
{
    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    public static void main(String[] args)
        throws Exception
    {
    	// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);
        
        String sourceFilePath = args[0];
        
        // Parse a Pcl program.
        Reader    reader = new FileReader(sourceFilePath);
        PclParser parser = new PclParser(reader);
        System.out.println("before program");
        SimpleNode rootNode = parser.program();
        System.out.println("after program");
		rootNode.dump(">");
        // Print the cross-reference table.
		CrossReferencer crossReferencer = new CrossReferencer();
		crossReferencer.print(symTabStack);

        // Visit the parse tree nodes to decorate them with type information.
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);
        
        // Print the parse tree.
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);

        Backend backend = BackendFactory.createBackend("compile");
        backend.process(iCode, symTabStack, objectFileName(sourceFilePath));
    }

    private static String fileNameWithoutExtension(String fileName) {
        int dotIndex = fileName.lastIndexOf('.');
        return fileName.substring(0, dotIndex);
    }

    private static String objectFileName(String fileName) {
        return fileNameWithoutExtension(fileName) + ".j";
    }
}
PARSER_END(PclParser)

SKIP: {
  " " | "\r" | "\t" | "\n"
  | <"//" (~["\n"])* ("\n"|"\r")?>
  //| <COMMENT : "{"(~["}"])*"}">
}

//TOKEN:
//{
////   //<NEW_LINE: "\n" >
//    <EOL : "\r" | "\n" | "\r\n">
//}

TOKEN : { //useful regex
	<#DIGIT  : ["0"-"9"]>
    |<#ONE_TO_NINE: ["1"-"9"] >
	  	//A-Z only if ignore case option is false
	| <#LETTER : ["a"-"z","A"-"Z"]>
	| <#SPACE: [" "] >
}

TOKEN : {//Reserved words
	<VAR : "var">
	| <IF : "if">
	| <ELSE_IF :"else if">
 	| <ELSE : "else">
 	| <FUNCTION : "function">
 	| <BOOLEAN : "boolean">
 	| <NUMBER : "number">
 	| <STRING : "char"> // made string parse as char so we can use pascal string
 	| <ENUM : "enum">
 	| <INTERFACE : "interface">
 	| <RETURN : "return">
 	| <VOID : "void">
 	| <WHILE : "while">
 	// Println is considered a reserved word for now. Might just want to make it part of the runtime library later.
 	| <PRINTLN : "println">
}

TOKEN : {//Symbols
	<NOT : "!">
	| <AMPRSAND : "&">
	| <MUL : "*">
	| <MINUS : "-">
	| <PLUS : "+">
	| <EQ : "=">
	| <BAR : "|">
	| <DIV : "/">
	| <COLON : ":">
	| <SEMICOLON : ";">
	| <QM : "?">
	| <COMMA : ",">
	| <DOT : ".">
	| <SINGLE_QUOTE : "'">
	| <QUOTE : "\"">
	| <LEFT_PARAN : "(">
	| <RIGHT_PARAN : ")">
	| <LEFT_BRAKET : "[">
	| <RIGHT_BRAKET : "]">
	| <LEFT_BRACE : "{"> 
	| <RIGHT_BRACE : "}">
	| <UNDER_SCORE : "_">
	| <LT : "<">
	| <GT : ">">
	| <LE : "<=">
	| <GE : ">=">
	| <DOUBLE_EQ : "==">
	| <OR : "||">
	| <AND : "&&">
	| <NOT_EQ : "!=">
}

TOKEN :
{
  <MATH_OP : <PLUS> | <MINUS> | <MUL> | <DIV> > 
}

TOKEN : {//Character String and Strings
	<STRING_LITERAL : <QUOTE> (~["\""])* <QUOTE> | <SINGLE_QUOTE> (~[]){1} <SINGLE_QUOTE> >
}

TOKEN : {//Identifier
	<IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> | "_")*>
}

/* TypeScript treats real and integers as Numbers*/
TOKEN : {//Numbers
	<NUM: <INTEGER> | <REAL>> 
	| <INTEGER: (<SIGN>)? (<DIGIT>)+ | (<ONE_TO_NINE> (<DIGIT>)+) >
	| <REAL: (<SIGN>)? (<DIGIT>)+ "." | (<SIGN>)? "." (<DIGIT>)+ | (<SIGN>)? (<DIGIT>)+ "." (<DIGIT>)+ >

	//for simple version you cant have -5 parse as number 
 	| <#SIGN: "" >
}

TOKEN: { /*	Error token */
    <ERROR : ~["\r", "\n"]>
}

SimpleNode program() : {}
{
	// Cross listing requires a program ID don't wana take it out
	{	  
	programId = symTabStack.enterLocal("TypeScript");
	programId.setDefinition(DefinitionImpl.PROGRAM);
	programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
	symTabStack.setProgramId(programId);
	}
		{
          System.out.println("before");
        }
        Statement_list() //(<EOF>)?
        {
          System.out.println("before1");
            return jjtThis;
            System.out.println("after");
        }
        {
          System.out.println("done parsing");
        }
        
}


/*if statements*/
void boolean_op()#void : {}
{
	<LT> #LESS_THAN |
	 <GT> #GREATER_THAN |
	  <LE> #LESS_THAN_OR_EQUALS |
	   <GE> #GREATER_THAN_OR_EQUALS |
	    <DOUBLE_EQ> #EQUALITY |
	     <OR> #OR |
	      <AND> #AND |
	       <NOT_EQ> #NOT_EQUALS 
}

void condition() : {}
{
    {
      System.out.println("before condition");
    }
    
	<LEFT_PARAN> Expression() boolean_op() Expression() <RIGHT_PARAN>
	{
	  System.out.println("after condition");
	}
	
}

void if_part() : {}
{
	<IF> condition() if_body()
}

void else_if_part(): {}
{
	<ELSE_IF> condition() if_body() //Compound_stmt()
}

void else_part(): {}
{
	<ELSE> if_body()
}
  

void if_body(): {}
{
  //<LEFT_BRACE>

		//( Assignment())*
		Compound_stmt()
  //<RIGHT_BRACE>
}
void if_stmt() :{}
{
	if_part() (else_if_part())* (else_part())?
}

void Statement()#void : {}
{
  // Might want to add "| Expression() <SEMICOLON>" here later, but doing so right now causes a choice conflict.
  	   	try
	{
  LOOKAHEAD(4)
	  
     Assignment() | if_stmt() | println() | Expression() < SEMICOLON >//| error() { handleError(token); }
    } catch(ParseException ex)
   {

     System.out.println("Exception!!!!");
     System.out.println("token :"+ex.currentToken.image);
//		handleError(ex.currentToken);
		HashSet syncSet = new HashSet();
        syncSet.add(SEMICOLON);
        syncSet.add(LEFT_BRACE);
        syncSet.add(RIGHT_BRACE);
        syncSet.add(EOF);
        handleError(ex, syncSet, true);
   }
  //| FunctionDeclaration() | If_stmt()
}

// TODO We need to implement general function parsing instead of just parsing println().
void println() : {}
{
    // TODO Once expression parsing works, allow for an expression to appear here instead of just factor()
    <PRINTLN> <LEFT_PARAN> factor() <RIGHT_PARAN> <SEMICOLON>
}

void Compound_stmt() : {}
{
  	<LEFT_BRACE> Statement_list() <RIGHT_BRACE>
}

void Statement_list() #void: {}
{
  {
    System.out.println("before stmt");
  }
  

  		(
  	  		Statement()

  	  	)+
  	  	{
  	  	  System.out.println("after stmt");
  	  	}
  	  	
}

void declaration() :{}
{
  VarIdentifierType() (<EQ> Expression())? <SEMICOLON>
}

void assignment_2() :{}
{
  <IDENTIFIER> 
		{
		  SymTabEntry typeId = symTabStack.lookup(token.image);
          typeId.appendLineNumber(token.beginLine);
          SymTabEntry variableId = symTabStack.lookup(token.image);
		  jjtThis.setAttribute(ID, variableId);
		  jjtThis.setTypeSpec(typeId.getTypeSpec());
		} #identifier  <EQ> Expression() <SEMICOLON>
}

void Assignment() :{}
{
  LOOKAHEAD(3)
  VarIdentifierType() (<EQ> Expression())? <SEMICOLON>|
  LOOKAHEAD(3)
		<IDENTIFIER> 
		{
		  SymTabEntry typeId = symTabStack.lookup(token.image);
          typeId.appendLineNumber(token.beginLine);
          SymTabEntry variableId = symTabStack.lookup(token.image);
		  jjtThis.setAttribute(ID, variableId);
		  jjtThis.setTypeSpec(typeId.getTypeSpec());
		} #identifier  <EQ> Expression() <SEMICOLON> 
}

void VarIdentifierType() #void : {}
{
    <VAR> IdentifierType()
}

void IdentifierType() #void :{SymTabEntry someID; ICodeNodeImpl old;}
{
    <IDENTIFIER> 
    {
      someID = symTabStack.enterLocal(token.image);
      processVariableDecl(token, someID);
      old = jjtThis;
	  jjtThis.setAttribute(ID, someID);  
      
    } #identifier <COLON>
    typeSignature()
    {
      SymTabEntry typeId = symTabStack.lookup(token.image);
      typeId.appendLineNumber(token.beginLine);
      TypeSpec type = typeId.getTypeSpec();
      someID.setTypeSpec(type);
      old.setTypeSpec(type);
    }
}

void typeSignature() #void :{}
{
	   <NUMBER>
	  |<BOOLEAN>
	  |<STRING>
}



void Expression() #void : {}
{
    LOOKAHEAD(3)
    term() (
        "+" term() #add(2)
      | "-" term() #subtract(2)
    )* |
    LOOKAHEAD(3)
    < LEFT_PARAN > term() (
        "+" term() #add(2)
      | "-" term() #subtract(2)
    )* < RIGHT_PARAN >  //|
	//LOOKAHEAD(3)
    //Assignment() //| if_stmt()
}

void simple_expression() #void :{}
{
	//factor()  //(MATH_OP factor())?
	factor() (("+"|"-"|"/"|"*") simple_expression())? //< SEMICOLON >
}

void term() #void : {}
{
    factor() (
        "*" factor() #multiply(2)
      | "/" factor() #divide(2)
    )*
}

void simple_term() #void : {}
{
  	LOOKAHEAD(3)
    factor() "*" factor() #multiply(2) |
    LOOKAHEAD(3)
    factor() "/" factor() #divide(2) |
    factor()
}

void factor() #void : {}
{
  LOOKAHEAD(3)
    identifier()
  | number()
  | string()
}


void identifier() : {} 
{
  <IDENTIFIER>
  {
	SymTabEntry variableId = symTabStack.lookup(token.image);
	variableId.appendLineNumber(token.beginLine);
	TypeSpec type = variableId.getTypeSpec();
	jjtThis.setTypeSpec(type);
	// ID is not really used but might need it later
	jjtThis.setAttribute(ID, variableId); 
  } 
}

// try parse integer if not try float if not error 
void number() : {}
{
  <NUM>
  {
  	  jjtThis.setTypeSpec(Predefined.numberType);
      jjtThis.setAttribute(VALUE, Double.parseDouble(token.image));
  }
}

void string() : {} 
{
  <STRING_LITERAL>
  {
  	  jjtThis.setTypeSpec(Predefined.charType);
	  jjtThis.setAttribute(VALUE, new String(token.image));
  }
}

void error() : {}
{
	<ERROR>
}

  
JAVACODE
//return the token name in string format
void processVariableDecl(Token token, SymTabEntry variableId) #void
{
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
}




JAVACODE
String handleError(ParseException ex, HashSet syncSet, boolean doPop) #void
{
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    // Consume tokens up to but not including a token in the sync set.
    while (!syncSet.contains(getToken(1).kind)) {
        token = getNextToken();
    } 	

    if (doPop) jjtree.popNode();
    return token.image;
}
